Тестирование программного обеспечения (Software Testing) — проверка соответствия между реальным и ожидаемым поведением программы, осуществляемая на конечном наборе тестов, выбранном определённым образом.

Главная цель тестировщика — удостовериться, что приложение работает, как ожидает пользователь

Жизненный цикл ПО:
● Планирование
● Анализ требований
● Проектирование и дизайн
● Разработка ПО
● Тестирование
● Поставка

Функциональное тестирование – это проверка соответствия программного обеспечения функциональным требованиям.
Функциональные требования – это детальное описание поведения программного обеспечения.
Функциональное тестирование бывает позитивным и негативным.
Позитивное тестирование – тестирование, при котором используются только сценарии корректной работы с системой.
При позитивном тестировании тестировщик не пытается вводить некорректные данные или сломать систему, в отличие от негативного тестирования.
Негативное тестирование – тестирование, при котором используются сценарии некорректной работы с системой и вводятся некорректные данные.

виды функционального тестирования:
● конфигурационное тестирование – тестирование работы программного обеспечения на различных окружениях.
● smoke-тестирование – проверка работоспособности базовых функциональностей программного обеспечения.
● регрессионное тестирование – тестирование системы, которое проводится после исправления дефектов или реализации новой функциональности.

Нефункциональное тестирование – это проверка соответствия программного обеспечения нефункциональным требованиям.
Нефункциональные требования – это требования, описывающие характеристики программного обеспечения, а не поведение системы.
Нефункциональными требованиями являются требования к производительности системы, к удобству ее использования, а также требования к масштабированию системы и безопасности.

виды нефункционального тестирования:
● юзабилити-тестирование – тестирование удобства и эффективности использования пользовательского интерфейса приложения.
● тестирование производительности – тестирование, проверяющее скорость и качество работы приложения под воздействием нагрузки.
● тестирование безопасности – проверка выполнения требований к безопасности и оценка риска использования уязвимостей при реальной атаке на приложение.

Чек-лист – список функциональностей и проверок к ним, которые будут содержаться при выполнении тестирования отдельных функций или всего приложения.
Обычно выделяют следующие статусы тестирования:
● Pass – Пройдено
● Fail – Не пройдено
● Skipped – Пропущен
● Not tested – Не тестировалось
● Blocked – Заблокировано

Тест-кейс — подробно описанный сценарий действий, которые необходимо выполнить в приложении, чтобы сравнить с ожидаемым поведением системы.
Тест-кейс один из наиболее важных документов тестировщика, потому что в нём описывается, как должно работать приложение. Как правило, он создаётся перед началом тестирования функциональности.
Тест-кейсы состоят из нескольких основных разделов:
● Уникальный номер - нужен для того, чтобы можно было найти тест-кейс по его номеру, а также для возможности удобно ссылаться на него.
● Название - должно быть максимально коротким, но понятным любому человеку.
● Приоритет (High — высокий, Middle/Medium — средний, Low — низкий)
● Предусловия - указываются подготовительные шаги для выполнения тест-кейса.
● Шаги - должны содержать абсолютно все действия, которые необходимо выполнить, глаголы должны быть в повелительном наклонении.
● Ожидаемый результат - Каждому шагу есть соответствующий ожидаемый результат.

Тестовый комплект — набор тест-кейсов, которые сгруппированы по определённому признаку. Признаки группировки могут быть разными:
● Для тестирования определенной функциональности или компонента
● Для smoke-тестирования
● Для регрессионного тестирования
● Позитивные и негативные
● Главные базовые сценарии использования
● И так далее

Баг-репорт – подробное описание бага, который был найден в программном обеспечении.
Баги делятся на:
● функциональные - несоответствия поведения приложения функциональным требованиям. Что-то в приложении не работает, хотя в требованиях явно прописано что должно.
● визуальные - баги интерфейса приложения, которые вы сможете выявить при помощи макетов, а в случае, если макетов нет, то при помощи здравого смысла и опыта.
● логические - какое-то логическое несоответствие. Например, можно поставить дату рождения ребенка до даты рождения его родителей.
● юзабилити - вы хотите выполнить какой-то свой сценарий, но вам его делать очень неудобно, приходится делать много дополнительных действий и, вместо того, чтобы быстро закрыть свой запрос, вы мучаетесь с приложением.
● безопасности - любая информация о пользователях (например, логины, пароли, электронная почта) не должны быть кому-то раскрыты.

Критичность и важность багов классифицируют  по матрице Дуайт Эйзенхауэра. Для бизнеса наиболее приоритетно, чтобы баги перестали приносить убытки. Поэтому в первую очередь делаются баги, которые больше всего беспокоят клиентов. А баги при этом могут быть совсем не критичными, т.е. не ломают существующий функционал, приложение не падает. Самое важное, чтобы выполнялись базовые сценарии использования приложения. Всегда ориентируйтесь на это в первую очередь.

По оформлению баг-репорты очень похожи на тест-кейсы и содержат схожие разделы:
● Уникальный номер бага
● Название
● Исполнитель - кто будет его исправлять
● Создатель - указывается автор бага
● Приоритет - (Blocker/Highest – наивысший, High – высокий, Middle/Medium – средний, Low – низкий)
● Предусловия - указываются подготовительные шаги для выполнения сценария воспроизведения бага
● Шаги для воспроизведения
● Ожидаемый результат
● Фактический результат

Требования к программному обеспечению (Техническое задание или ТЗ) – описание свойств и качеств программного обеспечения, которыми оно должно обладать. Если переводить на простой язык – это описание того, что должно уметь и делать приложение, а также как должно при этом выглядеть.

Иерархия требований:
● Бизнес-требования - описывают для кого нужен продукт и какую проблему или проблемы решает. Они верхнеуровневого описывают ту задачу, которую впоследствии должно решить приложение или конкретная функциональность.
Далее аналитики добавляют немного детализации и получаются пользовательские
требования. Они также не описывают непосредственную реализацию, но описывают непосредственные задачи пользователя, которые он хочет решать, а также говорят о том, кто наши пользователи.
● Пользовательские требования отвечают на три вопроса:
    ● для кого это нужно?
    ● что нужно?
    ● почему нужно?
Далее из пользовательских требований рождаются функциональные требования.
Например: “Я, как покупатель, хочу иметь возможность выбирать способ получения товара”. Чтобы реализовать это требование, нам необходимо добавить новые кнопки в интерфейс. Это и будут нашими функциональными требованиями:
Нефункциональные требования также декомпозируются из существующих функциональных:
    ● Система не должна хранить данные о доставке в базе данных, а должна их
    передавать в транспортную компанию.
    ● Пользователь должен оформить доставку в 3 клика.
    ● Пользователь должен тратить на оформление доставки не более 1 минуты.
